<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程Ⅴ----并发包锁和同步通信 | 博客</title><meta name="description" content="并发包部分结构"><meta name="keywords" content="并发"><meta name="author" content="fancylight"><meta name="copyright" content="fancylight"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="多线程Ⅴ----并发包锁和同步通信"><meta name="twitter:description" content="并发包部分结构"><meta name="twitter:image" content="https://www.fancylight.top/img/java.png"><meta property="og:type" content="article"><meta property="og:title" content="多线程Ⅴ----并发包锁和同步通信"><meta property="og:url" content="https://www.fancylight.top/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/"><meta property="og:site_name" content="博客"><meta property="og:description" content="并发包部分结构"><meta property="og:image" content="https://www.fancylight.top/img/java.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.fancylight.top/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/"><link rel="prev" title="多线程Ⅵ-JUC同步通信工具" href="https://www.fancylight.top/2021/03/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A5-JUC%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7/"><link rel="next" title="多线程Ⅳ-----基于AQS-Condition" href="https://www.fancylight.top/2021/03/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A3-%E5%9F%BA%E4%BA%8EAQS-Condition/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">56</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">1.</span> <span class="toc-text">JUC结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-number">1.1.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock的可见性"><span class="toc-number">1.1.1.</span> <span class="toc-text">Lock的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryLock操作"><span class="toc-number">1.1.2.</span> <span class="toc-text">tryLock操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重入锁ReentrantLock"><span class="toc-number">1.2.</span> <span class="toc-text">重入锁ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码原理"><span class="toc-number">1.2.1.</span> <span class="toc-text">源码原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特性"><span class="toc-number">1.2.2.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">1.3.</span> <span class="toc-text">ReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">1.3.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">多线程Ⅴ----并发包锁和同步通信</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-03-15<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-03-21</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span><div class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">3.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 14 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1>JUC结构</h1>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>JUC可以分为<code>AQS锁实现</code>,<code>线程池相关</code>,<code>同步通信工具</code>,<code>原子类</code>,<code>并发集合</code>,可以<a href="https://blog.csdn.net/weixin_38394991/article/details/105023356" target="_blank" rel="noopener">参考</a>,主要分析AQS锁实现,线程池,以及队列和并发集合实现.</p>
<h2 id="锁"><a class="header-anchor" href="#锁">¶</a>锁</h2>
<p>这里特指JUC中的<code>Lock</code>类,定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p><code>Lock</code>类具有以下性质:</p>
<ul>
<li>提供了更多操作,支持更加延展性的结构,通过可以关联多个Condition对象</li>
<li>一般来说是独占方式,但也可以支持共享,如ReadWriteLock</li>
<li>sync通过每个对象的监视器实现,获取多个锁和释放多个锁顺序相反</li>
<li>Lock实现了和Sync相同的语义,完成了可见性和原子性,前者是由于volatile本身的性质完成的</li>
<li>Lock可以响应中断操作</li>
</ul>
<h3 id="Lock的可见性"><a class="header-anchor" href="#Lock的可见性">¶</a>Lock的可见性</h3>
<p>在Lock的注释中描述了,<code>Lock</code>具有和<code>sync</code>相同的内存同步语义,以<code>ReentrantLock</code>为例,简化内部源码,如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read state</span><br><span class="line">    <span class="keyword">if</span> (can get lock)</span><br><span class="line">        write state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个变量a,考虑它的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        a++;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据happend-before原则:<code> volatile变量规则:可见性规则,该种变量的读取发生在写之后</code>,假设线程A,B同时获取锁,当A线程持有锁改变了a,并且释放锁,那么它的顺序就是 <code>写a--&gt;写state</code>,此时线程B被唤醒,在AQS中会再次执行<code>tryAcqurrie()</code>,从而经历<code>读state,读a</code>,<strong>由于volatile的性质,线程B能看见线程A写state之前的所有操作</strong>.</p>
<h3 id="tryLock操作"><a class="header-anchor" href="#tryLock操作">¶</a>tryLock操作</h3>
<p>一般使用如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>  (lock.tryLock()) &#123;</span><br><span class="line">        <span class="comment">//执行获取锁的操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获得锁失败</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();<span class="comment">//这一步必须执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重入锁ReentrantLock"><a class="header-anchor" href="#重入锁ReentrantLock">¶</a>重入锁ReentrantLock</h2>
<p>ReentrantLock的特性:</p>
<ul>
<li>支持同一个线程重入</li>
<li>支持公平和非公平锁</li>
</ul>
<h3 id="源码原理"><a class="header-anchor" href="#源码原理">¶</a>源码原理</h3>
<p>uml结构图如下:</p>
<img src="/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/2021-03-15-11-05-13.png" class="">
<p>ReentrantLock由内部类<code>FiarSync</code>和<code>NonFairSync</code>实现了同步机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;<span class="comment">//实际上的锁</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非公平锁,实际上就是直接在AQS中排队</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//重入性的实现</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//非公平锁</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//公平锁</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@ReservedStackAccess</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式选择</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行公平或非公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特性"><a class="header-anchor" href="#特性">¶</a>特性</h3>
<ul>
<li>非公平和公平的区别  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//直接修改资源,如果能够成功,则直接获取锁,不进入CLH</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公平实现</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <span class="comment">//判断是否第二个节点是当前线程,是则返回true,否则返回false</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出公平锁判断有其他节点等待就继续排队,非公平锁则是无视当前队伍尝试获取资源</p>
<ul>
<li>tryLock的实现<br>
通过调用nonfairTryAcquire,参与一次state的修改,但是不进入CLH队列,因此还是需要调用unlock函数</li>
</ul>
<h2 id="ReadWriteLock"><a class="header-anchor" href="#ReadWriteLock">¶</a>ReadWriteLock</h2>
<p>读写锁应用于读多,并且不占用过多时间,同时写线程不多的情况;内部采用两个Lock,实际共用同一个Sync,读锁使用share模式,写锁使用exclusive模式,这样就能实现读写互斥,写写互斥,读读共享的效果,其实现为<code>ReentrantReadWriteLock</code>和<code>StampedLock</code>,后者并不是直接实现</p>
<h3 id="ReentrantReadWriteLock"><a class="header-anchor" href="#ReentrantReadWriteLock">¶</a>ReentrantReadWriteLock</h3>
<ul>
<li>性质
<ul>
<li>响应中断</li>
<li>能够进行所谓的写锁降级,即一个线程可以先获取写锁,再获取读锁,不能相反</li>
</ul>
</li>
<li>结构</li>
<li>uml类图</li>
</ul>
 <img src="/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/2021-03-17-14-15-07.png" class="">
<p>内部AQS锁实现部分和<code>ReentrantLock</code>类似,只是<code>ReentrantReadWriteLock</code>内部存在<code>WriteLock</code>和<code>ReadLock</code>直接持有<code>Sync</code></p>
<ul>
<li>
<p>实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读锁,调用sync的share函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">//写锁,调用sync的非share函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">//共同的sync</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建公平或非公平sync</span></span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读Lock实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync; <span class="comment">//持有sync</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用共享</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写Lock同理,只是调用exclusive函数  </span></span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>锁结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读锁(共享)的移位,用来计算读锁资源</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//用来向state高位计算读锁占用数的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">//读写最大资源数量,写锁指的是重入次数,读锁指的是共享数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//写锁的掩码,用来计算写锁重入次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** Returns the number of shared holds represented in count. */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">/** Returns the number of exclusive holds represented in count. */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; <span class="comment">//计算读锁共享数量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125; <span class="comment">//计算读锁独占数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//该结构用来记录共享读锁的每个不同线程重入的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count;          <span class="comment">// initially 0</span></span><br><span class="line">         <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> tid = LockSupport.getThreadId(Thread.currentThread());</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//使用ThreadLocal来记录不同读线程,重写initaValue函数的目的是为了当调用get函数时,</span></span><br><span class="line">    <span class="comment">//如果当前线程为第一次,做一个初始化操作 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//记录读线程的ThreadLocal</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">     <span class="comment">//记录上一次读线程的缓存</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">     <span class="comment">//记录第一个读线程</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader;</span><br><span class="line">     <span class="comment">//记录第一个读线程的重入次数</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line">     <span class="comment">//读锁的公平或非公平实现要点</span></span><br><span class="line">     <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">//写锁的公平或非公平实现要点</span></span><br><span class="line">     <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">//----------------独占(写锁)SYNC实现-----------------</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Walkthrough:</span></span><br><span class="line"><span class="comment">          * 1. 若读或写线程存在,即c!=0,并且不是写重入,则失败</span></span><br><span class="line"><span class="comment">          * 2. 如果写饱和,则失败</span></span><br><span class="line"><span class="comment">          * 3. 否则根据队列策略,即writerShouldBlock,进行cas设置,若通过则获取锁,并设置独占线程</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">         <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">//存在其他线程</span></span><br><span class="line">             <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">             <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">//重入失败</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT) <span class="comment">//写饱和</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">             <span class="comment">// Reentrant acquire</span></span><br><span class="line">             setState(c + acquires); <span class="comment">//重入成功</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (writerShouldBlock() || <span class="comment">//排队策略,NonFair常为false,Fair则和重入锁实现相同</span></span><br><span class="line">             !compareAndSetState(c, c + acquires)) </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         setExclusiveOwnerThread(current); <span class="comment">//设置独占线程</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">         <span class="comment">//释放写资源    </span></span><br><span class="line">         <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">         <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (free) <span class="comment">//若写资源即state高16位都为0了,则释放独占线程</span></span><br><span class="line">             setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> free;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//------------共享(写锁)SYNC实现----------------</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">//减少firstReader的记录</span></span><br><span class="line">             <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">             <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                 firstReader = <span class="keyword">null</span>; <span class="comment">//若fristReader的重入次数只有一次了,那么就直接清除</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 firstReaderHoldCount--;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             HoldCounter rh = cachedHoldCounter;</span><br><span class="line">             <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                 rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                 rh = readHolds.get();</span><br><span class="line">             <span class="keyword">int</span> count = rh.count;</span><br><span class="line">             <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                 readHolds.remove();</span><br><span class="line">                 <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">             &#125;</span><br><span class="line">             --rh.count;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">int</span> c = getState();</span><br><span class="line">             <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                 <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                 <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                 <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                 <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Walkthrough:</span></span><br><span class="line"><span class="comment">          * 1. 如果写线程占用锁,则直接失败</span></span><br><span class="line"><span class="comment">          * 2. 否则根据排队策略判断是否排队. 如果不需要,则通过cas设置</span></span><br><span class="line"><span class="comment">          *    状态.这一步不进行重入检测.</span></span><br><span class="line"><span class="comment">          * 3. 如果由于步骤2中排队策略或者cas失败则进行fullTryAcquireShared</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="comment">//[1] 检测是否存在写线程,并且不是当前线程(所谓写锁降级)</span></span><br><span class="line">         <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">             getExclusiveOwnerThread() != current)</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">         <span class="comment">//[2] 满足条件排队策略成功,读数量未饱和,cas操作成功</span></span><br><span class="line">         <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">             r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">             compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">             <span class="comment">//开始记录不同读线程的重入次数,通过firstReader和cachedHoldCounter做优化    </span></span><br><span class="line">             <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                 firstReader = current;</span><br><span class="line">                 firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                 firstReaderHoldCount++;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                 <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                     rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                     cachedHoldCounter = rh = readHolds.get(); <span class="comment">//注意,这个get(),由于重写了initialValue(),如果不存在值,则会返回一个新值,并且加入ThreadLocal的map中</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)<span class="comment">//假设同一个读线程经过加锁,释放,第二次进入到这里就满足该条件(在release函数中有remove操作)</span></span><br><span class="line">                     readHolds.set(rh);</span><br><span class="line">                 rh.count++;<span class="comment">//增加重入次数</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//[3] 假设由于排队策略,或者cas失败,则需要一次补救措施</span></span><br><span class="line">         <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//采用for循环是为了cas成功</span></span><br><span class="line">         HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">int</span> c = getState();</span><br><span class="line">             <span class="comment">//[1] 检测是否存在写线程,并且不是当前线程(所谓写锁降级)</span></span><br><span class="line">             <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                 <span class="comment">// would cause deadlock.</span></span><br><span class="line">                 <span class="comment">//[2] 若由于排队策略,导致需要排队(排除重入情况)</span></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                 <span class="comment">// 用来排除重入锁的情况 </span></span><br><span class="line">                 <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">//这里说明此时是fristReader的重入操作,跳过</span></span><br><span class="line">                     <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//只要满足rh==null&amp;&amp;rh.count==0,就会导致此处仅仅记录一个cachedHoldCounter,不会存到readHolds中</span></span><br><span class="line">                     <span class="comment">//情况1: firstReader第一次进入,但是由于CLH有写锁排队(公平或非公平都应该是写锁排队导致),结果此处读操作,必定排队等待</span></span><br><span class="line">                     <span class="comment">//情况2: 第二个读线程,即firstReader还处于持有锁的状态,由于公平锁导致的排队,或者非公平的导致的排队</span></span><br><span class="line">                     <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                         rh = cachedHoldCounter;</span><br><span class="line">                         <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                             rh.tid != LockSupport.getThreadId(current)) &#123;</span><br><span class="line">                             rh = readHolds.get();</span><br><span class="line">                             <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                 readHolds.remove();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//若rh.count !=0,说明此时进行的是非firstReader的重入操作</span></span><br><span class="line">                     <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//[3] 判断读是否饱和</span></span><br><span class="line">             <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">             <span class="comment">//[4] 修改资源并记录线程状态    </span></span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                     firstReader = current;</span><br><span class="line">                     firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                     firstReaderHoldCount++;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                         rh = cachedHoldCounter;</span><br><span class="line">                     <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                         rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                         rh = readHolds.get();</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                         readHolds.set(rh);</span><br><span class="line">                     rh.count++;</span><br><span class="line">                     cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<ul>
<li>state分段<br>
将state分段为高16位和低16位,前者表示共享读锁的资源或重入情况,后者表示独占写锁的重入情况<br>
计算当前读锁数量<code>c &gt;&gt;&gt; SHARED_SHIFT</code>,计算写锁重入<code>c &amp; EXCLUSIVE_MASK</code>,增加读锁state<code>compareAndSetState(c, c + SHARED_UNIT)</code>,增加写锁<code>compareAndSetState(c, c + acquires)</code></li>
<li>记录每个不同读线程的重入情况<br>
使用<code>ThreadLocal</code>变量,内部为<code>HoldCounter</code>,保存线程id和重入次数,同时使用<code>firstReader</code>和<code>firstReaderHoldCount</code>把第一次读线程特殊保留,<code>cachedHoldCounter</code>用来记录上次的读线程<br>
<code>cachedHoldCounter</code>变量的作用是避免从<code>readHolds</code>中取数据,是一个缓存<br>
<code>firstReader</code>属于一种优化,减少向<code>readHolds</code>中操作,这两个变量都是为了减少记录读线程的操作<br>
这些记录只是为了<code>getReadHoldCount</code>函数</li>
</ul>
</li>
<li>
<p>排队策略<br>
通过两个函数<code>writerShouldBlock</code>和<code>readerShouldBlock</code>为实现公平和非公平锁</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平锁,即存在排队的节点,则排队</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">        <span class="comment">//写锁直接插队</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读锁会判断是否存在写锁排队,若存在则进入CLH排队,否插队</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">            * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">            * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">            * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">            * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">            * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 
</li>
</ul>
<p>这里读锁的非公平模式只是在判断了当排队的锁是写锁的时候不进行插队,并不能根本上的解决写饥饿的状态</p>
<hr>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="http://ifeve.com/java%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84/" target="_blank" rel="noopener">java锁是如何保证数据可见性的</a><br>
<a href="https://www.zhihu.com/question/41016480" target="_blank" rel="noopener">reentrantlock如何保证可见性</a><br>
<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">锁种类美团博客</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">fancylight</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.fancylight.top/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/">https://www.fancylight.top/2021/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A4-%E5%B9%B6%E5%8F%91%E5%8C%85%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.fancylight.top" target="_blank">博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发    </a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/03/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A5-JUC%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7/"><img class="prev_cover" src="/img/java.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多线程Ⅵ-JUC同步通信工具</div></div></a></div><div class="next-post pull_right"><a href="/2021/03/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%85%A3-%E5%9F%BA%E4%BA%8EAQS-Condition/"><img class="next_cover" src="/img/java.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程Ⅳ-----基于AQS-Condition</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/31/java并发/" title="java并发"><img class="relatedPosts_cover "src="/img/java.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-31</div><div class="relatedPosts_title">java并发</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/13/多线程Ⅰ----java线程对象/" title="多线程Ⅰ----java线程对象"><img class="relatedPosts_cover "src="/img/java.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-13</div><div class="relatedPosts_title">多线程Ⅰ----java线程对象</div></div></a></div><div class="relatedPosts_item"><a href="/2021/03/12/多线程Ⅳ-基于AQS-Condition/" title="多线程Ⅳ-----基于AQS-Condition"><img class="relatedPosts_cover "src="/img/java.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-12</div><div class="relatedPosts_title">多线程Ⅳ-----基于AQS-Condition</div></div></a></div><div class="relatedPosts_item"><a href="/2021/03/19/多线程Ⅵ-JUC同步通信工具/" title="多线程Ⅵ-JUC同步通信工具"><img class="relatedPosts_cover "src="/img/java.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-19</div><div class="relatedPosts_title">多线程Ⅵ-JUC同步通信工具</div></div></a></div><div class="relatedPosts_item"><a href="/2021/03/21/多线程Ⅶ-JUC线程池/" title="多线程Ⅶ---JUC线程池"><img class="relatedPosts_cover "src="/img/java.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-21</div><div class="relatedPosts_title">多线程Ⅶ---JUC线程池</div></div></a></div><div class="relatedPosts_item"><a href="/2021/03/23/多线程Ⅷ-JUC集合/" title="多线程Ⅷ-JUC集合"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-23</div><div class="relatedPosts_title">多线程Ⅷ-JUC集合</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '624d139155758ea48077',
  clientSecret: 'cc126a301586ea63779cec6a6b53101749dbc9dd',
  repo: 'gittalk_issue',
  owner: 'fancylight',
  admin: ['fancylight'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By fancylight</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>