<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>aop | 博客</title><meta name="description" content="aop"><meta name="keywords" content="框架,spring,springAop"><meta name="author" content="fancylight"><meta name="copyright" content="fancylight"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="aop"><meta name="twitter:description" content="aop"><meta name="twitter:image" content="https://www.fancylight.top/img/spring.png"><meta property="og:type" content="article"><meta property="og:title" content="aop"><meta property="og:url" content="https://www.fancylight.top/2019/05/25/aop/"><meta property="og:site_name" content="博客"><meta property="og:description" content="aop"><meta property="og:image" content="https://www.fancylight.top/img/spring.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.fancylight.top/2019/05/25/aop/"><link rel="prev" title="hbase" href="https://www.fancylight.top/2019/07/17/hbase/"><link rel="next" title="java动态代理" href="https://www.fancylight.top/2019/05/22/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">42</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring中aop的实现"><span class="toc-number">2.</span> <span class="toc-text">spring中aop的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从ProxyFactory开始"><span class="toc-number">2.1.</span> <span class="toc-text">从ProxyFactory开始</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#术语和类"><span class="toc-number">2.1.1.</span> <span class="toc-text">术语和类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类"><span class="toc-number">2.1.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#advice到advisor的转换"><span class="toc-number">2.1.3.</span> <span class="toc-text">advice到advisor的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring支持的代理模式"><span class="toc-number">2.2.</span> <span class="toc-text">spring支持的代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK-proxy"><span class="toc-number">2.2.1.</span> <span class="toc-text">JDK proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#开启jdk代理"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">开启jdk代理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#调用逻辑"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">调用逻辑</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#拦截器"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">拦截器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#切点"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">切点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springAop技术总结"><span class="toc-number">2.3.</span> <span class="toc-text">springAop技术总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#底层实现原理"><span class="toc-number">2.3.1.</span> <span class="toc-text">底层实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#语法角度"><span class="toc-number">2.3.2.</span> <span class="toc-text">语法角度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cglib在spring中的源码"><span class="toc-number">2.3.3.</span> <span class="toc-text">cglib在spring中的源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Aspectj使用"><span class="toc-number">2.3.4.</span> <span class="toc-text">Aspectj使用</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">aop</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-05-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-03-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span><div class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 35 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/05/25/aop/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h3 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h3>
<ul>
<li>springAop和AspectJ的关系<br>
在spring的aop模块中提供了切面编程实际上都是一种动态代理机制<br>
从实现来说一种是jdk代理,一种是cglib<br>
从语法上讲一种是使用aopalliance定义的advice来实现,一种是spring使用aspectj语法来实现<br>
从spring底层机制来说无论是直接使用aspectj语法还是使用advice类,过程都是将advisor转换成Interceptor的过程</li>
<li>真正的AspectJ<br>
spring提供了<code>spring.aspectJ</code>模块与其集成,AspectJ使用参考<a href="https://blog.mythsman.com/post/5d301cf2976abc05b34546be/" target="_blank" rel="noopener">AspectJ</a></li>
</ul>
<h3 id="spring中aop的实现"><a class="header-anchor" href="#spring中aop的实现">¶</a>spring中aop的实现</h3>
<h4 id="从ProxyFactory开始"><a class="header-anchor" href="#从ProxyFactory开始">¶</a>从ProxyFactory开始</h4>
<img src="/2019/05/25/aop/ProxyFactory.png" class="">
<ul>
<li>Advised接口表示包含了Interceptors|advice|advices|以及代理接口</li>
<li>Support都是包含了有效信息,提供组装的接口<br>
例子:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该例子使用了jdk代理</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">     factory.setTarget(<span class="keyword">new</span> MyProxyInstance());</span><br><span class="line">       factory.setInterfaces(ProxyInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       factory.addAdvice(<span class="keyword">new</span> BeforeMethod());</span><br><span class="line">       factory.addAdvice(<span class="keyword">new</span> AfterMethod());</span><br><span class="line">       factory.addAdvice(<span class="keyword">new</span> ThrowsAd());</span><br><span class="line">       factory.addAdvice(<span class="keyword">new</span> AroundMethod());</span><br><span class="line">       factory.addAdvice(<span class="keyword">new</span> IntrodcutionAdvice()); <span class="comment">//引介增强</span></span><br><span class="line">       <span class="keyword">this</span>.&lt;ProxyInterface&gt;getProxy().test();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="术语和类"><a class="header-anchor" href="#术语和类">¶</a>术语和类</h5>
<ul>
<li>术语
<ul>
<li>JoinPoint连接点,实际就是指的方法,其衍生的类有MethodInvocation表示一个方法调用</li>
<li>PointCut 切点,描述如何匹配位置,内部包含ClassFilter用来匹配类,MethodMatcher用来匹配方法</li>
<li>Advice 增强</li>
<li>Advisor 切面 包含了切点和增强,spring用PointCutAdvisor描述</li>
<li>拦截器 就是spring将advisor转换成动态代理时调用的逻辑</li>
</ul>
</li>
</ul>
<h5 id="类"><a class="header-anchor" href="#类">¶</a>类</h5>
<p>spring提供了基本五种advice可以通过实现方式不同做一个细分</p>
<ul>
<li>基本的非Introduction的advice
<ul>
<li>MethodBeforeAdvice<img src="/2019/05/25/aop/BeforeAdvice.png" class="">
</li>
<li>AfterReturningAdvice<img src="/2019/05/25/aop/afterRunnging.png" class="">
</li>
<li>ThrowsAdvice<img src="/2019/05/25/aop/ThrowsAdvice.png" class="">
</li>
<li>MethodInterceptor<img src="/2019/05/25/aop/MethodInterceptor.png" class="">  
</li>
</ul>
</li>
<li>Introduction类型的增强,实际就是添加了代理接口
<ul>
<li>该类在初始化时会获取实现类的直接父接口,也就是用户要增强的接口,源码在构造器部分,不写出来了</li>
</ul>
</li>
</ul>
<img src="/2019/05/25/aop/DelegatingIntroductionInterceptor.png" class="">    
<p>可以直观的看到上述5个接口其中环绕和引介本身都属于拦截器</p>
<h5 id="advice到advisor的转换"><a class="header-anchor" href="#advice到advisor的转换">¶</a>advice到advisor的转换</h5>
<p>该阶段发生在向ProxyFactory添加advice时,当然用户可以直接添加advisor</p>
<figure class="highlight java"><figcaption><span>AdvisedSupport</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = <span class="keyword">this</span>.advisors.size();</span><br><span class="line">		addAdvice(pos, advice);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> IntroductionInfo) &#123; <span class="comment">//实际上我们实现的引介增强提供了要代理的接口</span></span><br><span class="line">			<span class="comment">// We don't need an IntroductionAdvisor for this kind of introduction:</span></span><br><span class="line">			<span class="comment">// It's fully self-describing.</span></span><br><span class="line">			addAdvisor(pos, <span class="keyword">new</span> DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> DynamicIntroductionAdvice) &#123; <span class="comment">//不能直接添加这种引介</span></span><br><span class="line">			<span class="comment">// We need an IntroductionAdvisor for this kind of introduction.</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//非Introduction类型</span></span><br><span class="line">			addAdvisor(pos, <span class="keyword">new</span> DefaultPointcutAdvisor(advice));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理IntroductionInfo类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			validateIntroductionAdvisor((IntroductionAdvisor) advisor);</span><br><span class="line">		&#125;</span><br><span class="line">		addAdvisorInternal(pos, advisor);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//从IntroductionAdvisor获取要增强的接口</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateIntroductionAdvisor</span><span class="params">(IntroductionAdvisor advisor)</span> </span>&#123;</span><br><span class="line">		advisor.validateInterfaces();</span><br><span class="line">		<span class="comment">// If the advisor passed validation, we can make the change.</span></span><br><span class="line">		Class&lt;?&gt;[] ifcs = advisor.getInterfaces();</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; ifc : ifcs) &#123;</span><br><span class="line">			addInterface(ifc);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>引介基本Advisor</p>
<img src="/2019/05/25/aop/DefaultIntroductionAdvisor.png" class="">
<p>注意增强advice匹配条件仅仅是类,因此该advisor并不是<code>PointCut</code>子类,仅仅是<code>ClassFilter</code>子类</p>
<figure class="highlight java"><figcaption><span>DefaultIntroductionAdvisor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个参数一般情况就是用户实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultIntroductionAdvisor</span><span class="params">(Advice advice, @Nullable IntroductionInfo introductionInfo)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.advice = advice;</span><br><span class="line">		<span class="keyword">if</span> (introductionInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Class&lt;?&gt;[] introducedInterfaces = introductionInfo.getInterfaces(); <span class="comment">//获取增加的接口</span></span><br><span class="line">			<span class="keyword">if</span> (introducedInterfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"IntroductionAdviceSupport implements no interfaces"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; ifc : introducedInterfaces) &#123;</span><br><span class="line">				addInterface(ifc); <span class="comment">//将信息的接口添加进set</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultPointcutAdvisor:典型的PointCutAdvisor,由 内部PointCut决定匹配</p>
<figure class="highlight java"><figcaption><span>DefaultPointcutAdvisor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultPointcutAdvisor</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(Pointcut.TRUE, advice); <span class="comment">//Pointcut默认匹配所有Class的任意Method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="spring支持的代理模式"><a class="header-anchor" href="#spring支持的代理模式">¶</a>spring支持的代理模式</h4>
<p>jdk Proxy和cglib</p>
<figure class="highlight java"><figcaption><span>ProxyFactory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[1] 外部接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//[2] aop代理</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">			activate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>); <span class="comment">//ProxyFactory本身就是一个配置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//类DefaultAopProxyFactory,通过代理AopProxyFactory创建AopProxy</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用户没有提供要代理的接口,即config#interfaces为空或者只有SpringProxy接口被代理</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">		return (ifcs.length == 0 || (ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0])));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>spring提供了两种代理 jdk和cglib,前者的实现导致只能对接口进行代理,后者可以对类进行代理</li>
<li>设置ProxyTargetClass=true,表示接受目标是类时,直接代理和代理接口一样;一般来当传递的target为类,这样就是开启cglib.</li>
<li>&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt; | @EnableAspectJAutoProxy(proxyTargetClass = true)</li>
</ul>
<h5 id="JDK-proxy"><a class="header-anchor" href="#JDK-proxy">¶</a>JDK proxy</h5>
<h6 id="开启jdk代理"><a class="header-anchor" href="#开启jdk代理">¶</a>开启jdk代理</h6>
<ul>
<li>jdk代理过程中,将target作为最终原本调用的代理对象,可以参看proxy代理部分,也就是说该对象不指定或者并不是接口对象,那么必定会导致最终调用异常</li>
<li>只有主动调用setInterfaces才能启用jdk代理,否则就是cglib代理,当然除去代理对象本身就是个接口(会抛出异常),或者代理对象本身是个Proxy类(即jdk proxy生成的类)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory factory=<span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    <span class="comment">//关于spring jdk代理</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (T)factory.getProxy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        factory.setTarget(<span class="keyword">new</span> NoInterface());</span><br><span class="line">        factory.setInterfaces(<span class="keyword">new</span> Class[]&#123;ProxyInterface<span class="class">.<span class="keyword">class</span>,<span class="title">ProxyInterface2</span>.<span class="title">class</span>&#125;)</span>;</span><br><span class="line">        <span class="keyword">this</span>.&lt;ProxyInterface&gt;getProxy().test(); <span class="comment">//此处会跳出异常</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="调用逻辑"><a class="header-anchor" href="#调用逻辑">¶</a>调用逻辑</h6>
<ul>
<li>注意该类本身就是一个InvocationHandler,因此其invoke函数就是支持代理执行的逻辑</li>
</ul>
<figure class="highlight java"><figcaption><span>JdkDynamicAopProxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//advised即ProxyFactory本身,该函数生成了该代理模式下生成的所有接口</span></span><br><span class="line">		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//确定是否重写了equals和hash方法</span></span><br><span class="line">		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">		<span class="comment">//jdk代理</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>spring如何获取代理接口的
<ul>
<li>这个函数说明的问题是,想使用jdk proxy的动作是主动添加interface,而不是仅仅传递target,spring并没有主动解析目标类的父接口</li>
</ul>
</li>
</ul>
<figure class="highlight java"><figcaption><span>AopProxyUtils</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, <span class="keyword">boolean</span> decoratingProxy) &#123;</span><br><span class="line">		Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">		<span class="comment">//当用户没有提供代理接口时,检查是否代理对象是一个proxy</span></span><br><span class="line">		<span class="keyword">if</span> (specifiedInterfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// No user-specified interfaces: check whether target class is an interface.</span></span><br><span class="line">			Class&lt;?&gt; targetClass = advised.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">					advised.setInterfaces(targetClass);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">					advised.setInterfaces(targetClass.getInterfaces());</span><br><span class="line">				&#125;</span><br><span class="line">				specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> addSpringProxy = !advised.isInterfaceProxied(SpringProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">boolean</span> addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">boolean</span> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">		<span class="keyword">int</span> nonUserIfcCount = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//spring会主动添加三个代理接口 SpringProxy   | Advised   |DecoratingProxy</span></span><br><span class="line">		<span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">			nonUserIfcCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">			nonUserIfcCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (addDecoratingProxy) &#123;</span><br><span class="line">			nonUserIfcCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt;[] proxiedInterfaces = <span class="keyword">new</span> Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount];</span><br><span class="line">		System.arraycopy(specifiedInterfaces, <span class="number">0</span>, proxiedInterfaces, <span class="number">0</span>, specifiedInterfaces.length);</span><br><span class="line">		<span class="keyword">int</span> index = specifiedInterfaces.length;</span><br><span class="line">		<span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">			proxiedInterfaces[index] = SpringProxy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">			proxiedInterfaces[index] =  <span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (addDecoratingProxy) &#123;</span><br><span class="line">			proxiedInterfaces[index] = DecoratingProxy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> proxiedInterfaces;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JdkDynamicAopProxy#invoke,这是代理逻辑</li>
</ul>
<figure class="highlight java"><figcaption><span>JdkDynamicAopProxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//此处体现了目标源</span></span><br><span class="line">		TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">		Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">		       <span class="comment">//没有重写equals,调用Object#equals</span></span><br><span class="line">				<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				<span class="comment">//同上</span></span><br><span class="line">				<span class="keyword">return</span> hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="comment">// 如果调用是DecoratingProxy#getDeclaringClass则调用如下函数</span></span><br><span class="line">				<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				<span class="comment">// 这个函数的逻辑实际就是调用method.invoke,jdk反射调用函数</span></span><br><span class="line">				<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">				<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//获取代理目标</span></span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//获取拦截链,这是核心逻辑之一</span></span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		     <span class="comment">//如果拦截链为空,则调用反射</span></span><br><span class="line">			<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">				<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">				<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//创建一个使用拦截逻辑的方法调用,核心逻辑之一</span></span><br><span class="line">				invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">					returnType != Object<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">returnType</span>.<span class="title">isInstance</span>(<span class="title">proxy</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">					!<span class="title">RawTargetAccess</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">				<span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">				<span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">				<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">						<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">				<span class="comment">// Restore old proxy.</span></span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明此处的<code>targetSource</code>,如果使用spring中jdk代理不提供源|或者目标源和代理接口并非实现关系,那么当真正函数调用时spring会抛出异常,<br>
这里实际上就是我在<a href="/2019/05/22/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#%E6%80%BB%E7%BB%93">jdk动态代理</a>提及的若不提供源,那么代理无意义.</li>
<li>获取拦截链<br>
这里的逻辑剥离了advisor,其中切点用来筛选,而advice用来创建拦截链</li>
</ul>
<figure class="highlight java"><figcaption><span>AdvisedSupport</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存机制  method-拦截链</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">		List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">		<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">			cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">					<span class="keyword">this</span>, method, targetClass);</span><br><span class="line">			<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cached;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//AdvisorAdapterRegistry用来创建拦截器</span></span><br><span class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">		Advisor[] advisors = config.getAdvisors();</span><br><span class="line">		List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</span><br><span class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">		Boolean hasIntroductions = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123; <span class="comment">////默认的前置  后置 抛出 环绕 都时这种类型</span></span><br><span class="line">				<span class="comment">// Add it conditionally.</span></span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123; <span class="comment">//做一次类型匹配</span></span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); <span class="comment">//获取方法匹配器</span></span><br><span class="line">					<span class="keyword">boolean</span> match;</span><br><span class="line">					<span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123; <span class="comment">//不清楚的方法匹配其类型</span></span><br><span class="line">						<span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</span><br><span class="line">							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">						&#125;</span><br><span class="line">						match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						match = mm.matches(method, actualClass); <span class="comment">//匹配一次</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (match) &#123;</span><br><span class="line">						MethodInterceptor[] interceptors = registry.getInterceptors(advisor); <span class="comment">//创造拦截器,返回数组说明用户实现的部分可以属于多个增强</span></span><br><span class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123; <span class="comment">//动态切点则创建动态拦截器</span></span><br><span class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123; <span class="comment">//引介增强</span></span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> interceptorList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the Advisors contain matching introductions.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasMatchingIntroductions</span><span class="params">(Advisor[] advisors, Class&lt;?&gt; actualClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拦截器创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">		List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">		Advice advice = advisor.getAdvice();</span><br><span class="line">		<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123; <span class="comment">//环绕 引介本身就是拦截器</span></span><br><span class="line">			interceptors.add((MethodInterceptor) advice);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123; <span class="comment">//其他三种通过适配器创建</span></span><br><span class="line">			<span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">				interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>拦截器调用逻辑</li>
</ul>
<figure class="highlight java"><figcaption><span>拦截器调用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line"><span class="comment">//创建ReflectiveMethodInvocation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ReflectiveMethodInvocation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.proxy = proxy; <span class="comment">//代理对象</span></span><br><span class="line">		<span class="keyword">this</span>.target = target; <span class="comment">//代理目标</span></span><br><span class="line">		<span class="keyword">this</span>.targetClass = targetClass; <span class="comment">//目标class类型</span></span><br><span class="line">		<span class="keyword">this</span>.method = BridgeMethodResolver.findBridgedMethod(method); <span class="comment">//方法</span></span><br><span class="line">		<span class="keyword">this</span>.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments); <span class="comment">//参数</span></span><br><span class="line">		<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers; <span class="comment">//该方法对应的拦截链</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拦截器的调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//	当拦截器调用结束则使用反射,去调用函数本身,实际就是递归的返回条件</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123; <span class="comment">//动态切点就会匹配到这里</span></span><br><span class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">			<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123; <span class="comment">//做一次动态匹配,如果匹配成功就调用</span></span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>); <span class="comment">//调用拦截器中的增强</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果动态拦截器失败则进行下一个拦截</span></span><br><span class="line">				<span class="keyword">return</span> proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">			<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br></pre></td></tr></table></figure>
<p>此处对于非动态拦截器采取了一种十分有趣的写法,具体实现不好描述,简单的理解为递归调用<br>
默认的5种类型拦截器放置顺序都能保证正确的执行,只是具体顺序有些不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">     factory.setTarget(<span class="keyword">new</span> MyProxyInstance());</span><br><span class="line">        factory.setInterfaces(ProxyInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> AroundMethod());</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> AfterMethod());</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> BeforeMethod());</span><br><span class="line">        <span class="keyword">this</span>.&lt;ProxyInterface&gt;getProxy().test();</span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line"><span class="comment">//test环绕前</span></span><br><span class="line"><span class="comment">//test前执行</span></span><br><span class="line"><span class="comment">//采取jdk proxy</span></span><br><span class="line"><span class="comment">//test执行后</span></span><br><span class="line"><span class="comment">//test环绕后</span></span><br><span class="line">	  factory.setTarget(<span class="keyword">new</span> MyProxyInstance());</span><br><span class="line">        factory.setInterfaces(ProxyInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> ThrowsAd());</span><br><span class="line">		factory.addAdvice(<span class="keyword">new</span> AfterMethod());</span><br><span class="line">        factory.addAdvice(<span class="keyword">new</span> AroundMethod());</span><br><span class="line">        <span class="keyword">this</span>.&lt;ProxyInterface&gt;getProxy().test();</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">test环绕前</span><br><span class="line">test前执行</span><br><span class="line">采取jdk proxy</span><br><span class="line">test环绕后</span><br><span class="line">test执行后</span><br></pre></td></tr></table></figure>
<h6 id="拦截器"><a class="header-anchor" href="#拦截器">¶</a>拦截器</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">BeforeAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//mi表示方法调用</span></span><br><span class="line">		<span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis()); <span class="comment">//调用用户实现</span></span><br><span class="line">		<span class="keyword">return</span> mi.proceed();<span class="comment">//可以理解为递归,等待此处循环调用结束,因此before实现的部分一定会在方法调用前被调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置拦截</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">AfterAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object retVal = mi.proceed(); <span class="comment">//继续递归执行</span></span><br><span class="line">		<span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());<span class="comment">//只有递归结束后才能调用,因此该逻辑必然在函数调用后才能被调用</span></span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环绕拦截实际是一个普通的拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundMethod</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method= invocation.getMethod();</span><br><span class="line">        Object arg[]= invocation.getArguments();</span><br><span class="line">        System.out.println(method.getName()+<span class="string">"环绕前"</span>);</span><br><span class="line"><span class="comment">//        Object re=method.invoke(invocation.getThis(),arg);  这句代码就会导致递归返回,如果该method拦截链没有调用完,那么就会到此为止</span></span><br><span class="line">        <span class="keyword">var</span> re= invocation.proceed(); <span class="comment">//如此调用就会继续进入拦截链逻辑</span></span><br><span class="line">        System.out.println(method.getName()+<span class="string">"环绕后"</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异常拦截器,由于ThrowsAdvice是个标记接口,因此在该拦截器中定义用户能够实现的函数模式<br>
<code>public void afterThrowing(Exception ex)</code><br>
<code>public void afterThrowing(RemoteException)</code><br>
<code>public void afterThrowing(Method method, Object[] args, Object target, Exception ex)</code><br>
<code>public void afterThrowing(Method method, Object[] args, Object target, ServletException ex)</code><br>
函数名必须时<code>afterThrowing</code></li>
</ul>
<figure class="highlight java"><figcaption><span>ThrowsAdviceInterceptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThrowsAdviceInterceptor</span><span class="params">(Object throwsAdvice)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(throwsAdvice, <span class="string">"Advice must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.throwsAdvice = throwsAdvice;</span><br><span class="line"></span><br><span class="line">		Method[] methods = throwsAdvice.getClass().getMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">			<span class="keyword">if</span> (method.getName().equals(AFTER_THROWING) &amp;&amp;</span><br><span class="line">					(method.getParameterCount() == <span class="number">1</span> || method.getParameterCount() == <span class="number">4</span>)) &#123;<span class="comment">//检查函数名和参数</span></span><br><span class="line">				Class&lt;?&gt; throwableParam = method.getParameterTypes()[method.getParameterCount() - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (Throwable<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">throwableParam</span>)) </span>&#123; <span class="comment">//若符合</span></span><br><span class="line">					<span class="comment">// An exception handler to register...</span></span><br><span class="line">					<span class="keyword">this</span>.exceptionHandlerMap.put(throwableParam, method); <span class="comment">//缓存 exception-method的 map</span></span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">"Found exception handler method on throws advice: "</span> + method);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.exceptionHandlerMap.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">					<span class="string">"At least one handler method must be found in class ["</span> + throwsAdvice.getClass() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拦截链调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mi.proceed(); <span class="comment">//递归逻辑</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123; <span class="comment">//当递归返回,并捕获异常后处理</span></span><br><span class="line">			Method handlerMethod = getExceptionHandler(ex); <span class="comment">//匹配对应异常的处理函数</span></span><br><span class="line">			<span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">				invokeHandlerMethod(mi, ex, handlerMethod); <span class="comment">//调用用户实现的handlerMethod</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeHandlerMethod</span><span class="params">(MethodInvocation mi, Throwable ex, Method method)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object[] handlerArgs;</span><br><span class="line">		<span class="keyword">if</span> (method.getParameterCount() == <span class="number">1</span>) &#123; <span class="comment">//处理handler会用到的参数</span></span><br><span class="line">			handlerArgs = <span class="keyword">new</span> Object[] &#123;ex&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			handlerArgs = <span class="keyword">new</span> Object[] &#123;mi.getMethod(), mi.getArguments(), mi.getThis(), ex&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			method.invoke(<span class="keyword">this</span>.throwsAdvice, handlerArgs); <span class="comment">//调用异常处理handler</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException targetEx) &#123;</span><br><span class="line">			<span class="keyword">throw</span> targetEx.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引介拦截器</li>
</ul>
<figure class="highlight java"><figcaption><span>DelegatingIntroductionInterceptor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingIntroductionInterceptor</span> <span class="keyword">extends</span> <span class="title">IntroductionInfoSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">IntroductionInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">//链接链调用		</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isMethodOnIntroducedInterface(mi)) &#123; <span class="comment">//判断此次method是不是增强的函数</span></span><br><span class="line">		    <span class="comment">//如果是则调用反射,只是反射的instance是this,就能调用用户实现增强</span></span><br><span class="line">			Object retVal = AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.delegate, mi.getMethod(), mi.getArguments());</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果返回的是this则中断递归逻辑</span></span><br><span class="line">			<span class="keyword">if</span> (retVal == <span class="keyword">this</span>.delegate &amp;&amp; mi <span class="keyword">instanceof</span> ProxyMethodInvocation) &#123;</span><br><span class="line">				Object proxy = ((ProxyMethodInvocation) mi).getProxy();</span><br><span class="line">				<span class="keyword">if</span> (mi.getMethod().getReturnType().isInstance(proxy)) &#123;</span><br><span class="line">					retVal = proxy;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//递归逻辑</span></span><br><span class="line">		<span class="keyword">return</span> doProceed(mi);</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="切点"><a class="header-anchor" href="#切点">¶</a>切点</h6>
<p>切点可以分为 静态切点 | 动态切点 | 流程切点 | 以及默认的全匹配切点|复合切点|匹配name的切点<br>
切点实际上就是实现了PointCut,MethodMathcher的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//methodMathcher</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建拦截链时调用</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"><span class="comment">//该条件反应了该切点是不是动态的,动态切点会在每次函数调用再做一次匹配</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//动态匹配条件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line"><span class="comment">//默认的全匹配方法拦截器</span></span><br><span class="line">MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pointcut</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"><span class="comment">//拦截链条件之一</span></span><br><span class="line"><span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>; <span class="comment">//存在默认的全Class匹配器</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//默认的全匹配切点</span></span><br><span class="line">Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>spring提供了一个静态advisor,可以直接使用StaticMethodMatcherPointcutAdvisor,或者我们实现静态切点StaticMethodMatcherPointcut使用默认defaultAdvisor</li>
<li>动态则提供了一个切点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicMethodMatcherPointcut</span> <span class="keyword">extends</span> <span class="title">DynamicMethodMatcher</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ClassFilter.TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际上这是一个切点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.aop.MethodMatcher#matches(Method, Class, Object...)</span></span><br><span class="line"><span class="comment"> * 第三个参数表示当函数运行时判断形参,也就是说该切面判定在于运行期,而不是Context解析的过程中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPointcut</span> <span class="keyword">extends</span> <span class="title">DynamicMethodMatcherPointcut</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getClassFilter(); <span class="comment">// 默认匹配所有,这个测试中只有该切面只对应了一个target,所以我不写了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先因该判断类,省略</span></span><br><span class="line">        <span class="comment">//匹配函数,省略,因为只有一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.matches(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//该函数会在method调用的时候再做一次,形参args的匹配,也就是说每次函数调用传递的参数不同,也许就不满足条件,这就是动态匹配的意思</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此刻就能对于函数进行动态匹配,也就是说在参数不同的情况下对于目标做出不同的处理,默认不进行处理</span></span><br><span class="line">        <span class="keyword">return</span> list.contains(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>流程切点	ControlFlowPointcut</li>
</ul>
<figure class="highlight java"><figcaption><span>流程切点</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配条件有 类 和 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ControlFlowPointcut</span><span class="params">(Class&lt;?&gt; clazz, @Nullable String methodName)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(clazz, <span class="string">"Class must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">		<span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//动态匹配条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.evaluations++;</span><br><span class="line">        <span class="comment">//获取调用方法栈,当类和方法匹配时启动代理</span></span><br><span class="line">		<span class="keyword">for</span> (StackTraceElement element : <span class="keyword">new</span> Throwable().getStackTrace()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (element.getClassName().equals(<span class="keyword">this</span>.clazz.getName()) &amp;&amp;</span><br><span class="line">					(<span class="keyword">this</span>.methodName == <span class="keyword">null</span> || element.getMethodName().equals(<span class="keyword">this</span>.methodName))) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>复合切点</li>
</ul>
<figure class="highlight java"><figcaption><span>ComposablePointcut</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposablePointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认为全匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComposablePointcut</span><span class="params">(MethodMatcher methodMatcher)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(methodMatcher, <span class="string">"MethodMatcher must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.classFilter = ClassFilter.TRUE;</span><br><span class="line">		<span class="keyword">this</span>.methodMatcher = methodMatcher;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComposablePointcut <span class="title">intersection</span><span class="params">(ClassFilter other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.classFilter = ClassFilters.intersection(<span class="keyword">this</span>.classFilter, other);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ComposablePointcut <span class="title">intersection</span><span class="params">(MethodMatcher other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.methodMatcher = MethodMatchers.intersection(<span class="keyword">this</span>.methodMatcher, other);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ComposablePointcut <span class="title">intersection</span><span class="params">(Pointcut other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.classFilter = ClassFilters.intersection(<span class="keyword">this</span>.classFilter, other.getClassFilter());</span><br><span class="line">		<span class="keyword">this</span>.methodMatcher = MethodMatchers.intersection(<span class="keyword">this</span>.methodMatcher, other.getMethodMatcher());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何实现 交逻辑 | 并逻辑类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectionMethodMatcher</span> <span class="keyword">implements</span> <span class="title">MethodMatcher</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MethodMatcher mm1;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">final</span> MethodMatcher mm2;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">IntersectionMethodMatcher</span><span class="params">(MethodMatcher mm1, MethodMatcher mm2)</span> </span>&#123;</span><br><span class="line">			Assert.notNull(mm1, <span class="string">"First MethodMatcher must not be null"</span>);</span><br><span class="line">			Assert.notNull(mm2, <span class="string">"Second MethodMatcher must not be null"</span>);</span><br><span class="line">			<span class="keyword">this</span>.mm1 = mm1;</span><br><span class="line">			<span class="keyword">this</span>.mm2 = mm2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//静态方法匹配条件改为&amp;&amp;满足</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.mm1.matches(method, targetClass) &amp;&amp; <span class="keyword">this</span>.mm2.matches(method, targetClass));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//是否为动态则取决于存在就进行动态匹配</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.mm1.isRuntime() || <span class="keyword">this</span>.mm2.isRuntime());</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//动态匹配条件</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Because a dynamic intersection may be composed of a static and dynamic part,</span></span><br><span class="line">			<span class="comment">// we must avoid calling the 3-arg matches method on a dynamic matcher, as</span></span><br><span class="line">			<span class="comment">// it will probably be an unsupported operation.</span></span><br><span class="line">			<span class="keyword">boolean</span> aMatches = (<span class="keyword">this</span>.mm1.isRuntime() ?</span><br><span class="line">					<span class="keyword">this</span>.mm1.matches(method, targetClass, args) : <span class="keyword">this</span>.mm1.matches(method, targetClass));</span><br><span class="line">			<span class="keyword">boolean</span> bMatches = (<span class="keyword">this</span>.mm2.isRuntime() ?</span><br><span class="line">					<span class="keyword">this</span>.mm2.matches(method, targetClass, args) : <span class="keyword">this</span>.mm2.matches(method, targetClass));</span><br><span class="line">			<span class="keyword">return</span> aMatches &amp;&amp; bMatches;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引介(引介不是匹配方法而是类),因此并不是实现PointCut,在第一部分有 advice-&gt;advisor的转换中就提到了引介切面DefaultIntroductionAdvisor<br>
引介增强DelegatingIntroductionInterceptor,本身就属于一个拦截器,用户实现该接口,直接添加该advice,spring会自动创建DefaultIntroductionAdvisor<br>
我们也可以手动创建</li>
</ul>
<img src="/2019/05/25/aop/DefaultIntroductionAdvisor.png" class="">
<p>我们可以看见该切面并不是Pointcut也不是MethodMatcher</p>
<ul>
<li>A B类循环引用,最终问题情况</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--关于早期引用代理问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"ioc.problem.A"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"ioc.problem.B"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"flowHelp"</span> <span class="attr">class</span>=<span class="string">"aop.jdkProxy.FlowHelp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInstance"</span> <span class="attr">class</span>=<span class="string">"aop.jdkProxy.MyProxyInstance"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"advice"</span> <span class="attr">class</span>=<span class="string">"aop.BeforeMethod"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInstanceProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:proxyTargetClass</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:interceptorNames</span>=<span class="string">"advice"</span> <span class="attr">p:beanNames</span>=<span class="string">"a"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        xml.loadBeanDefinitions(<span class="string">"aop2.xml"</span>);</span><br><span class="line">        beanFactory.addBeanPostProcessor((BeanPostProcessor) beanFactory.getBean(<span class="string">"myInstanceProxy"</span>));</span><br><span class="line">        beanFactory.getBean(<span class="string">"myInstance"</span>,MyProxyInstance<span class="class">.<span class="keyword">class</span>).<span class="title">test</span>()</span>;</span><br><span class="line">        <span class="comment">//早期引用代理</span></span><br><span class="line">        A a= (A) beanFactory.getBean(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//结果并不是一个循环,而是(代理A)-&gt;null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原因:</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">			<span class="comment">//当早期对象循环结束回到当前bean时</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);  <span class="comment">//会从缓存最终获取早期bean</span></span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123; <span class="comment">//若早期bean和当前不同则会导致覆盖</span></span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				<span class="comment">//不同的原因就在于smart接口创建了一个早期代理对象,反正最终结果很奇怪</span></span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">								<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">								<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">								<span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="springAop技术总结"><a class="header-anchor" href="#springAop技术总结">¶</a>springAop技术总结</h4>
<h5 id="底层实现原理"><a class="header-anchor" href="#底层实现原理">¶</a>底层实现原理</h5>
<img src="/2019/05/25/aop/aop%E6%8A%80%E6%9C%AF.png" class="">
<ul>
<li>字节码操作技术: ASM JDKPROXY JAVASIST</li>
<li>不使用<code>Instrumentation</code>的情况基本都是运行时织入
<ul>
<li>运行织入技术如<code>cglib</code> ,'jdkProxy’都会生成目标类的子类代理对象,这是为了解决类加载器重复加载问题.</li>
</ul>
</li>
<li>关于上述几个框架,我暂时不做源码分析,使用参考<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a></li>
<li>spring中无论使用jdk代理还是cglib实际上都是将advice-&gt;advisor,分别在InvocationHandler | cglib的MethodIntertor中实现拦截链</li>
</ul>
<h5 id="语法角度"><a class="header-anchor" href="#语法角度">¶</a>语法角度</h5>
<img src="/2019/05/25/aop/springAop%E8%AF%AD%E6%B3%95.png" class="" title="springAop语法">
<ul>
<li>spring支持接口或类代理,分别使用了jdk和cglib实现</li>
<li>为了拓展语法,spring也支持了aspectJ语法,在不使用<code>LTW</code>技术的情况下,原理还是上述两种</li>
</ul>
<h5 id="cglib在spring中的源码"><a class="header-anchor" href="#cglib在spring中的源码">¶</a>cglib在spring中的源码</h5>
<img src="/2019/05/25/aop/ObjenesisCglibAopProxy.png" class="">
<p>这个大体框架和JdkDynamicAopProxy是类似的</p>
<figure class="highlight java"><figcaption><span>CglibAopProxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</span><br><span class="line">		<span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.advised = config;</span><br><span class="line">		<span class="keyword">this</span>.advisedDispatcher = <span class="keyword">new</span> AdvisedDispatcher(<span class="keyword">this</span>.advised);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//实际创建代理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Creating CGLIB proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass(); <span class="comment">//代理源对象</span></span><br><span class="line">			Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">			Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">			<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123; <span class="comment">//处理接口</span></span><br><span class="line">				proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">				Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">					<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">			validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Configure CGLIB Enhancer... cglib Enhancer设置</span></span><br><span class="line">			Enhancer enhancer = createEnhancer();</span><br><span class="line">			<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">				enhancer.setClassLoader(classLoader);</span><br><span class="line">				<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">						((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">					enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">			enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">			enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">			Callback[] callbacks = getCallbacks(rootClass); <span class="comment">//创建Callbcak</span></span><br><span class="line">			Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">				types[x] = callbacks[x].getClass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">			enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">					<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">			enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">			<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">					<span class="string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">					ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//---------------------------getCallbacks---------------------------------</span></span><br><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// Parameters used for optimization choices...</span></span><br><span class="line">		<span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">		<span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">		<span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose an "aop" interceptor (used for AOP calls).</span></span><br><span class="line">    <span class="comment">//DynamicAdvisedInterceptor 是cglib中的MethodInteceptor实现类比于jdkProxy的InvocationHandler</span></span><br><span class="line">		Callback aopInterceptor = <span class="keyword">new</span> DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose a "straight to target" interceptor. (used for calls that are</span></span><br><span class="line">		<span class="comment">// unadvised but can return this). May be required to expose the proxy.</span></span><br><span class="line">		Callback targetInterceptor;</span><br><span class="line">		<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">			targetInterceptor = (isStatic ?</span><br><span class="line">					<span class="keyword">new</span> StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">					<span class="keyword">new</span> DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			targetInterceptor = (isStatic ?</span><br><span class="line">					<span class="keyword">new</span> StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">					<span class="keyword">new</span> DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose a "direct to target" dispatcher (used for</span></span><br><span class="line">		<span class="comment">// unadvised calls to static targets that cannot return this).</span></span><br><span class="line">		Callback targetDispatcher = (isStatic ?</span><br><span class="line">				<span class="keyword">new</span> StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) : <span class="keyword">new</span> SerializableNoOp());</span><br><span class="line"></span><br><span class="line">		Callback[] mainCallbacks = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">				aopInterceptor,  <span class="comment">// for normal advice</span></span><br><span class="line">				targetInterceptor,  <span class="comment">// invoke target without considering advice, if optimized</span></span><br><span class="line">				<span class="keyword">new</span> SerializableNoOp(),  <span class="comment">// no override for methods mapped to this</span></span><br><span class="line">				targetDispatcher, <span class="keyword">this</span>.advisedDispatcher,</span><br><span class="line">				<span class="keyword">new</span> EqualsInterceptor(<span class="keyword">this</span>.advised),</span><br><span class="line">				<span class="keyword">new</span> HashCodeInterceptor(<span class="keyword">this</span>.advised)</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the target is a static one and the advice chain is frozen,</span></span><br><span class="line">		<span class="comment">// then we can make some optimizations by sending the AOP calls</span></span><br><span class="line">		<span class="comment">// direct to the target using the fixed chain for that method.</span></span><br><span class="line">		<span class="keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">			Method[] methods = rootClass.getMethods();</span><br><span class="line">			Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</span><br><span class="line">			<span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap&lt;&gt;(methods.length);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> small memory optimization here (can skip creation for methods with no advice)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; x++) &#123;</span><br><span class="line">				List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</span><br><span class="line">				fixedCallbacks[x] = <span class="keyword">new</span> FixedChainStaticTargetInterceptor(</span><br><span class="line">						chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line">				<span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), x);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Now copy both the callbacks from mainCallbacks</span></span><br><span class="line">			<span class="comment">// and fixedCallbacks into the callbacks array.</span></span><br><span class="line">			callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">			System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</span><br><span class="line">			System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line">			<span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			callbacks = mainCallbacks;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> callbacks;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//---------------------------------DynamicAdvisedInterceptor----------------------------------------</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.advised = advised;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">			Object target = <span class="keyword">null</span>;</span><br><span class="line">			TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">					<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">					oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">					setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span></span><br><span class="line">				target = targetSource.getTarget();</span><br><span class="line">				Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//注意这里 获取拦截链,这里的逻辑和jdk就是相同的了,后边没什么值得分析的了</span></span><br><span class="line">				List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">				Object retVal;</span><br><span class="line">				<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">				<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">				<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">					<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">					<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">					<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">					<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">					Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">					retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">					retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">				&#125;</span><br><span class="line">				retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">				<span class="keyword">return</span> retVal;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">					targetSource.releaseTarget(target);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">					<span class="comment">// Restore old proxy.</span></span><br><span class="line">					AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Aspectj使用"><a class="header-anchor" href="#Aspectj使用">¶</a>Aspectj使用</h5>
<ul>
<li>AspectJProxyFactory使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void test2()&#123;</span><br><span class="line">        AspectJProxyFactory aspectJProxyFactory &#x3D; new AspectJProxyFactory();</span><br><span class="line">        aspectJProxyFactory.setTarget(new AocTarget2());</span><br><span class="line">        aspectJProxyFactory.addAspect(AnnotationAspect.class);</span><br><span class="line">        AocTarget2 aocTarget2 &#x3D;  aspectJProxyFactory.getProxy();</span><br><span class="line">        aocTarget2.annotationAspectTest();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理</li>
</ul>
<figure class="highlight java"><figcaption><span>AspectJProxyFactory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建advisor的工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AspectJAdvisorFactory aspectFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAspect</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">		String aspectName = aspectClass.getName();</span><br><span class="line">    <span class="comment">//关于Metadata是 ascpetTool中的概念</span></span><br><span class="line">		AspectMetadata am = createAspectMetadata(aspectClass, aspectName);</span><br><span class="line">		MetadataAwareAspectInstanceFactory instanceFactory = createAspectInstanceFactory(am, aspectClass, aspectName);</span><br><span class="line">    <span class="comment">//根据源信息创建advisor</span></span><br><span class="line">		addAdvisorsFromAspectInstanceFactory(instanceFactory);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//-------------------addAdvisorsFromAspectInstanceFactory------------------------------</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAdvisorsFromAspectInstanceFactory</span><span class="params">(MetadataAwareAspectInstanceFactory instanceFactory)</span> </span>&#123;</span><br><span class="line">		List&lt;Advisor&gt; advisors = <span class="keyword">this</span>.aspectFactory.getAdvisors(instanceFactory);</span><br><span class="line">		Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">		Assert.state(targetClass != <span class="keyword">null</span>, <span class="string">"Unresolvable target class"</span>);</span><br><span class="line">		advisors = AopUtils.findAdvisorsThatCanApply(advisors, targetClass);</span><br><span class="line">		AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(advisors);</span><br><span class="line">		AnnotationAwareOrderComparator.sort(advisors);</span><br><span class="line">		addAdvisors(advisors);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------  ReflectiveAspectJAdvisorFactory-------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Aspect类信息</span></span><br><span class="line">		Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">		String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">		validate(aspectClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">		<span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">		MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">				<span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">		List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历Aspect类中函数,除了被标记为@PointCut注解的</span></span><br><span class="line">		<span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">			Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">			<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				advisors.add(advisor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">		<span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">			Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">			advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Find introduction fields.</span></span><br><span class="line">    <span class="comment">// 引介处理</span></span><br><span class="line">		<span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">			Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">			<span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				advisors.add(advisor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> advisors;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------getAdvisorMethods---------------------</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">			<span class="comment">// Exclude pointcuts</span></span><br><span class="line">			<span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut<span class="class">.<span class="keyword">class</span>) </span>== <span class="keyword">null</span>) &#123;</span><br><span class="line">				methods.add(method);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		methods.sort(METHOD_COMPARATOR);</span><br><span class="line">		<span class="keyword">return</span> methods;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//------------------getAdvisor----------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    <span class="comment">//根据符合条件的函数创建切点</span></span><br><span class="line">		AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">				candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">		<span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//创建advisor,这标准的PointcutAdvisor</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">				<span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">	&#125;  </span><br><span class="line"><span class="comment">//--------------------getDeclareParentsAdvisor------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Advisor <span class="title">getDeclareParentsAdvisor</span><span class="params">(Field introductionField)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据aspect中的属性,创建引介advisor</span></span><br><span class="line">		DeclareParents declareParents = introductionField.getAnnotation(DeclareParents<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (declareParents == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Not an introduction field</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (DeclareParents<span class="class">.<span class="keyword">class</span> </span>== declareParents.defaultImpl()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"'defaultImpl' attribute must be set on DeclareParents"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DeclareParentsAdvisor(</span><br><span class="line">				introductionField.getType(), declareParents.value(), declareParents.defaultImpl());</span><br><span class="line">	&#125;  </span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">fancylight</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.fancylight.top/2019/05/25/aop/">https://www.fancylight.top/2019/05/25/aop/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.fancylight.top" target="_blank">博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架    </a><a class="post-meta__tags" href="/tags/spring/">spring    </a><a class="post-meta__tags" href="/tags/springAop/">springAop    </a></div><div class="post_share"><div class="social-share" data-image="/img/spring.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/07/17/hbase/"><img class="prev_cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hbase</div></div></a></div><div class="next-post pull_right"><a href="/2019/05/22/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"><img class="next_cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java动态代理</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/04/Spring-aop织入分析/" title="Spring_aop织入分析"><img class="relatedPosts_cover "src="/img/spring.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-04</div><div class="relatedPosts_title">Spring_aop织入分析</div></div></a></div><div class="relatedPosts_item"><a href="/2019/02/19/SpringMVC源码/" title="SpringMVC体系"><img class="relatedPosts_cover "src="/img/spring.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-02-19</div><div class="relatedPosts_title">SpringMVC体系</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/01/spring-cache/" title="spring-cache"><img class="relatedPosts_cover "src="/img/spring.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-01</div><div class="relatedPosts_title">spring-cache</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/26/springMVC核心/" title="springMVC核心"><img class="relatedPosts_cover "src="/img/spring.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-26</div><div class="relatedPosts_title">springMVC核心</div></div></a></div><div class="relatedPosts_item"><a href="/2019/09/05/springBoot学习一/" title="springBoot学习一"><img class="relatedPosts_cover "src="/img/spring.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-09-05</div><div class="relatedPosts_title">springBoot学习一</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/14/spring/" title="spring"><img class="relatedPosts_cover "src="/img/spring.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-14</div><div class="relatedPosts_title">spring</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '624d139155758ea48077',
  clientSecret: 'cc126a301586ea63779cec6a6b53101749dbc9dd',
  repo: 'gittalk_issue',
  owner: 'fancylight',
  admin: ['fancylight'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By fancylight</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>