<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>c++基础 | 博客</title><meta name="description" content="c++基础"><meta name="keywords" content="基础"><meta name="author" content="fancylight"><meta name="copyright" content="fancylight"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="c++基础"><meta name="twitter:description" content="c++基础"><meta name="twitter:image" content="https://www.fancylight.top/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="c++基础"><meta property="og:url" content="https://www.fancylight.top/2019/01/04/c-%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="博客"><meta property="og:description" content="c++基础"><meta property="og:image" content="https://www.fancylight.top/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.fancylight.top/2019/01/04/c-%E5%9F%BA%E7%A1%80/"><link rel="prev" title="c++杂项" href="https://www.fancylight.top/2019/01/04/c/"><link rel="next" title="标准库源码-io" href="https://www.fancylight.top/2018/11/12/%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81-io/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">54</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">c++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">一、常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">指针 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">作用域和生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code%EF%BF%BC10"><span class="toc-number">1.2.</span> <span class="toc-text"><!-- hexo-inject:begin --><!-- hexo-inject:end -->1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&#x2F;&#x2F;main.cpp
#include &lt;iostream&gt;
class T&amp;#123;
public:
    void test()&amp;#123;&amp;#125;;
    void x();
&amp;#125;;
int main()&amp;#123;
    T t;
    t.test();
    t.x();
&amp;#125;
&#x2F;&#x2F;此时 t.test t.x
&#x2F;&#x2F;t.h
#ifndef ELFREAD_T_H
#define ELFREAD_T_H

#include &lt;iostream&gt;
class T&amp;#123;
public:
    void test()&amp;#123;
        std::cout&lt;&lt;123;
    &amp;#125;;
    void x();
&amp;#125;;

#endif &#x2F;&#x2F;ELFREAD_T_H
&#x2F;&#x2F;test.cpp
#include &lt;iostream&gt;
#include &quot;t.h&quot;
void T:: x()&amp;#123;
    std::cout&lt;&lt;&quot;xx&quot;;
&amp;#125;

</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">构造器相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text">二、关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">1.3.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef%E5%92%8Cusing"><span class="toc-number">1.3.2.</span> <span class="toc-text">typedef和using</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">1.3.3.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">1.3.4.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace"><span class="toc-number">1.3.5.</span> <span class="toc-text">命名空间namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-struct-union"><span class="toc-number">1.3.6.</span> <span class="toc-text">class struct union</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%8F"><span class="toc-number">1.4.</span> <span class="toc-text">三、宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%AE%8F%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.使用宏的保护机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-%E8%A1%A8%E7%A4%BA%E5%AE%8F%E7%9A%84%E6%8D%A2%E8%A1%8C"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.使用\表示宏的换行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">四、其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.使用{}进行初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E4%BA%8Ec-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.关于c++内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B7%A6%E5%8F%B3%E5%80%BC"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 左右值</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 目录</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">c++基础</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-01-04<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-05-09</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/C/">C</a></span><div class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 18 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2019/01/04/c-%E5%9F%BA%E7%A1%80/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1>c++基础</h1>
<h2 id="一、常见问题"><a class="header-anchor" href="#一、常见问题">¶</a>一、常见问题</h2>
<h3 id="指针-数组"><a class="header-anchor" href="#指针-数组">¶</a>指针 数组</h3>
<p>关于指针,实际就是addr,在汇编代码中对应着M[R[xx]];引用类型,只是语法对指针做的一层封装,在传递值的语言以及函数中,拥有对象控制权限,那么传递的就是引用.</p>
<p>1.指针的实质:</p>
<ul>
<li>对于指针的类型决定了其每次进行移位操作时,内存地址的偏移大小,而任意类型指针其所占的内存大小咋取决于程序和机器内存地址位数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
<li>void *类型指针可以代表任意指针类型,作为形参可以接受任意指针,指针之间的互相转换也是非常合理的.</li>
<li>指向指针指针类型如 int**p,从语法角度来理解p是一个指针,其指向了一个int*指针,也就是说该指针内存存放这一个指针的地址 <code>int \*p1=0; int \*\*p=&amp;p1</code>;</li>
<li>只想指针的引用类型 *&amp;ref</li>
</ul>
<p>2.数组的实质:</p>
<p>数组表示一段连续的空间,c++很容易将指针和数组概念不能完全分清楚.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.栈上分配数组</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> *a1= a;</span><br><span class="line">	<span class="keyword">int</span> a2 = *a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>汇编代码:<br>
首先[addr]不是间接取址 而是直接取址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="number">00</span>C64CB8  mov         dword ptr [ebp<span class="number">-14</span>h],<span class="number">1</span>  <span class="comment">//此处的地址就是a符号</span></span><br><span class="line"><span class="number">00</span>C64CBF  mov         dword ptr [ebp<span class="number">-10</span>h],<span class="number">2</span>  </span><br><span class="line"><span class="number">00</span>C64CC6  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">3</span>  </span><br><span class="line">	<span class="keyword">int</span> *a1 = a;                            <span class="comment">//将a赋予一个指针,就是将该数组首位内存地址计算出来并且给了指针</span></span><br><span class="line"><span class="number">00</span>C64CCD  lea         eax,[ebp<span class="number">-14</span>h]  </span><br><span class="line"><span class="number">00</span>C64CD0  mov         dword ptr [ebp<span class="number">-20</span>h],eax  </span><br><span class="line">	<span class="keyword">int</span> a2 = *a;</span><br><span class="line"><span class="number">00</span>C64CD3  mov         eax,<span class="number">4</span>  </span><br><span class="line"><span class="number">00</span>C64CD8  imul        ecx,eax,<span class="number">0</span>   <span class="comment">//计算偏移</span></span><br><span class="line"><span class="number">00</span>C64CDB  mov         edx,dword ptr [ebp+ecx<span class="number">-14</span>h]  ecx=<span class="number">0</span> [ebp<span class="number">-14</span>h]=a</span><br><span class="line"><span class="number">00</span>C64CDF  mov         dword ptr [ebp<span class="number">-2</span>Ch],edx  </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>堆上分配数组</span><br><span class="line"><span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">//c++中使用new关键字后,该函数本身就会返回一个指针</span></span><br><span class="line"><span class="comment">//此中情况下a指针指向的就是数组元素的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上结论可以通过反汇编自行证明</span></span><br></pre></td></tr></table></figure>
<p>结论:</p>
<ul>
<li>对于数组如果是局部变量其本身就是通过栈维护的几个连续元素,语法上使用首元素[index]的形式进行访问;</li>
<li>如果将局部数组a符号赋值给数组,那么相当于引用了新的指针变量,指针变量内容为数组元素地址</li>
<li>使用堆数组则表现的如同java语言</li>
</ul>
<p>3.关于数组和指针在语法上的一些使用:</p>
<ul>
<li>c++中语法中数组名=指针</li>
<li>既然使用指针来控制数组,那么每次进行的偏移量是根据指针类型确定的,而数组长度则未知,在传递参数时,要告知数组长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型指针和数组参数传递</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span>*p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;int*p&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于数组名[xx] 和指针 对于编译器来说当作参数时相同对待 看作一个指针值</span></span><br><span class="line">    <span class="comment">//这两个函数重复定义</span></span><br><span class="line"><span class="comment">//    void point(int array[])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        std::cout&lt;&lt;&quot;int*p&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    void point(int array[10])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        std::cout&lt;&lt;&quot;int*p&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param p 指向int[10] 这种类型数组名,每次偏移为type*length ,接受类型为数组指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pointArrayFun</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;p[<span class="number">1</span>]-p[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//指针的类型就是控制每次偏移的位置,对于p来说每次偏移的量就是10*4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param p为指向指针的指针,可以接受类型为 type *array[xx] 指针数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">arrayPointFun</span><span class="params">(<span class="keyword">int</span>**p)</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;p&lt;&lt;std::endl; <span class="comment">//本例子中代表了arrayPoint数组的首位地址</span></span><br><span class="line">        std::cout&lt;&lt;*p&lt;&lt;std::endl;<span class="comment">//代表了a的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pointAndArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> array[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>* arrayPoint[<span class="number">10</span>]=&#123;&amp;a,&amp;b&#125;;</span><br><span class="line">        <span class="comment">//匹配指针</span></span><br><span class="line">        <span class="built_in">arrayPointFun</span>(arrayPoint);</span><br><span class="line"></span><br><span class="line">        <span class="built_in"><span class="keyword">int</span></span> (*pointArray)[<span class="number">10</span>]=&amp;array;</span><br><span class="line">        <span class="built_in">pointArrayFun</span>(pointArray);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>4.函数指针和函数名</p>
<ul>
<li>函数名等同于函数指针,也就是说在作为形参,函数名可以匹配函数参数和函数指针参数,无非是在使用的时候是否要使用*符号</li>
<li>当返回复杂类型 使用 auto fun()-&gt;return type</li>
</ul>
<hr>
<h3 id="作用域和生命周期"><a class="header-anchor" href="#作用域和生命周期">¶</a>作用域和生命周期</h3>
<p>c++的作用域有编译单元即文件,函数,函数内部出现的{}符号</p>
<ul>
<li>全a局符号:</li>
<li>delclear 声明 如外部函数声明,外部变量声明属于<code>弱符号</code>,对于c++未使用extern关键的外部变量声明会被编译器解释为全局变量这样的强符号</li>
<li>define 全局函数=类函数,全局变量定义都属于<code>强符号</code></li>
<li>static 修饰静态全局变量,为当前编译单元所有,静态变量可以声明在函数体中</li>
<li>局部变量:<br>
定义在函数体作用域中,编译过程分配在栈上的变量,当作用域结束后随着栈回收而回收</li>
<li>关于类:<br>
c++将类作为了全局符号,类中的函数作为了全局函数,static 类函数只是从编译器的角度来看是静态类函数,而不是和默认static 作为静态单元关键字来使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ELFREAD_T_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFREAD_T_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ELFREAD_T_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;t.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T::test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ELFREAD_T2_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFREAD_T2_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ELFREAD_T2_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;t2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T::test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>这两个cpp在链接过程就会出现全局符号重复定义
</code></pre>
<p>头文件在c++语言中的作用就是将所谓的声明和定义分开,去看一下链接过程就能完全明白,按照上述定义的符号来理解,头文件的用法就是用来写外部符号,也就是所谓的 declear声明.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMakeFiles\elfRead.dir&#x2F;objects.a(test2.cpp.obj): In function &#96;ZN1T4testEv&#39;:</span><br><span class="line">F:&#x2F;code&#x2F;clionProject&#x2F;elfRead&#x2F;test2.cpp:6: multiple definition of &#96;T::test()&#39;</span><br><span class="line">CMakeFiles\elfRead.dir&#x2F;objects.a(test.cpp.obj):F:&#x2F;code&#x2F;clionProject&#x2F;elfRead&#x2F;test.cpp:6: first defined here</span><br></pre></td></tr></table></figure>
<pre><code>这是minGW链接时提示的错误,说明类函数的确是被汇编器当作全局符号的,链接过程在符号解析的过程中抛出错误;
即使此处不适用头文件,直接使用两个cpp,里边写相同的class定义,也会如此.
</code></pre>
<p>补充:<br>
对于语法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="function">type <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//至少在minGW编译器中会将之看作声明,就是说在头文件中,可以进行类函数的实现,当该函数被引入其实现cpp中,如果在cpp再次实现该函数,会在`预处理`过程中提示`重复定义`</span></span><br><span class="line"><span class="comment">//当这种类头文件被引入其他使用者的编译头中,并不会在链接过程中出现任何问题,按照逻辑来说t.h 进行声明,t.cpp中进行定义,如果t.h中实现了一个类函数,就相当于一个全局符号,当xx.cpp引如t.h,在预处理展开后,也就出现了一个全局符号,链接时就应该出错.</span></span><br><span class="line"><span class="comment">//但是事实与之相反,并不会出现链接错误,就说明上述语法被编译器作为声明而非定义</span></span><br></pre></td></tr></table></figure>
<h2 id="code￼10"><a class="header-anchor" href="#code￼10">¶</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    t.<span class="built_in">test</span>();</span><br><span class="line">    t.<span class="built_in">x</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时 t.test t.x</span></span><br><span class="line"><span class="comment">//t.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ELFREAD_T_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFREAD_T_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="number">123</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ELFREAD_T_H</span></span></span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;t.h&quot;</span></span></span><br><span class="line"><span class="keyword">void</span> T:: <span class="built_in">x</span>()&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;xx&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2>
<h3 id="构造器相关"><a class="header-anchor" href="#构造器相关">¶</a>构造器相关</h3>
<p>1.默认构造器<br>
默认构造器不完成任何内容,定义了其他构造器后,编译器不会再创建默认构造器,可以通过default关键字保留默认构造器  XX()=default;<br>
2.构造器初始化列表顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line"> <span class="keyword">int</span> b;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//构造器初始化顺序时按照变量位置进行的</span></span><br><span class="line">   <span class="built_in">F</span>(<span class="keyword">int</span> c,<span class="keyword">int</span> d):<span class="built_in">b</span>(c),<span class="built_in">a</span>(b)&#123;</span><br><span class="line">       std::cout&lt;&lt;a&lt;&lt;std::endl;</span><br><span class="line">       std::cout&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">       <span class="comment">//4201358</span></span><br><span class="line">       <span class="comment">//1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.拷贝构造函数和赋值操作符完成了深拷贝工作</p>
<ul>
<li>拷贝构造函数的调用时机:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">F</span>(<span class="keyword">const</span> F&amp;f)<span class="comment">//默认的拷贝</span></span><br><span class="line">    F&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> F&amp;f)<span class="comment">// 默认的赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Person p2=p; <span class="comment">//创造新的对象时调用 也就是这条语句编译器认为是调用了拷贝构造器 参数是p2的地址和p的地址</span></span><br><span class="line">Pserson p=p2; <span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发生值传递/返回值也会调用拷贝构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对于这种返回值的情况</span></span><br><span class="line"><span class="comment">*  1.如果Person重写了析构函数,也就是说明Person含有指针对象,并且是在析构中delete了指针对象,那么对于形参p的拷贝对象实参p,就会在结束时造成实参p内存指针内存被回收</span></span><br><span class="line"><span class="comment">   2.编译器优化会自动使用移动语义,就会避免返回值的析构发生</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">void test2(Person p)&#123;</span></span><br><span class="line"><span class="comment"> return p; //此时在AX寄存器中又创建了一个p对象</span></span><br><span class="line"><span class="comment"> //当该函数结束时,会调用参数p对象的析构和返回p对象的析构</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void test3()&#123;</span></span><br><span class="line"><span class="comment"> Person p;</span></span><br><span class="line"><span class="comment"> Pserson px;</span></span><br><span class="line"><span class="comment"> Person p2=test2(p); //拷贝构造</span></span><br><span class="line"><span class="comment"> px=test2(p); //赋值运算符</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>了解一个事实,编译器对于形参无论是X86还是IA32都创建了一个<code>新的</code>,无论是任何类型,形参所占用的空间和实参是相同</p>
<ul>
<li>基本数据类型形参在栈或者寄存器拷贝一份当作形参</li>
<li>指针类型相同,指针本身对于汇编来说也只是一个 <code>值</code>而已</li>
<li>类类型 分为值传递和引用传递, 前者对于栈对象,如果直接传递对象本身,相当于调用构造器创建新的形参对象;后者指栈对象传递引用或者取地址,都会传递该对象首地址,堆对象和传递引用和指针是相同的.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line"> <span class="keyword">int</span> b;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">F</span>(<span class="keyword">int</span> c,<span class="keyword">int</span> d):<span class="built_in">a</span>(c),<span class="built_in">d</span>(b)&#123;&#125;</span><br><span class="line"> <span class="built_in">F</span>(F&amp;f)&#123;a=f.a;b=f.b;&#125; <span class="comment">//拷贝构造函数,参数必须是引用类型,否则相当于不断的调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.析构函数</p>
<ul>
<li>会在栈对象销毁后调用,堆对象调用delete过程中free函数调用前调用</li>
<li>析构函数本身{}中由程序员编写,用来释放类中指针成员,指针成员编译器自动释放</li>
<li>如果重写了析构函数,那么相对来说就要重写一个拷贝构造函数和拷贝赋值运算符,因为拷贝对于指针成员来说是浅拷贝,指针会指向同一块,重写的拷贝函数应该完成指针对象构造,具体看3.</li>
<li>指针作为基本数据类型,并不会触发析构函数,所以传递类对象时,传递引用就不会发生上述重写析构导致的内存回收</li>
</ul>
<p>5.委托构造函数,构造器调用前调用另一个构造完成初始化,以及其中的逻辑代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line"> <span class="keyword">int</span> b;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">F</span>(<span class="keyword">int</span> c,<span class="keyword">int</span> d):<span class="built_in">a</span>(c),<span class="built_in">d</span>(b)&#123;&#125;</span><br><span class="line"> <span class="built_in">F</span>():<span class="built_in">F</span>(<span class="number">1</span>,<span class="number">2</span>)&#123;&#125; <span class="comment">//委托构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.隐式类型转换可以通过explicit关键字屏蔽<br>
7.仅仅使用数据的类使用struct<br>
8.关于c++ 指针 引用 值 类构造器</p>
<ul>
<li>首先将指针和引用看作相同的,两者都占用空间,并且其值都是地址,只是c++编译器在语法上对两者进行了区别,属于不同类型,可以参与重载</li>
<li>值传递:参数在汇编指令下会进行一次值复制操作,无论该实参的类型,只是在c++语法层面将这个问题复杂化了<br>
1.关于基本类值传递,就是简单的复制操作;对于简单类型的引用或者指针传递,被称之为引用传递,实际对于引用/指针来说还是存在一次地址值的复制操作,作为寄存器或栈值进行函数调用,只是该参数的行为改动的是原值的<br>
2.对于复杂类型类的值传递问题,对于语法层面的值传递,会导致拷贝构造函数的调用,返回值也是,都存在了创建一份新的对象的操作;当传递指针和引用时候,值传递的是地址值,此时的参数复制工作并不会涉及原对象的拷贝工作<br>
3.关于析构函数,析构函数本身并不做什么工作,对于类成员变量的清除,默认析构函数也不会进行;对于汇编代码的堆栈指针变化造成的所谓<code>回收堆栈</code>也不会对内存本身数据造成改变,只是在语法上不让代码访问,形参也是如此,不过X86形参会放在寄存器中;这里要说的意思是,只有你的析构函数主动清除了指针成员指向的内存,此时返回临时引用才会造成问题.</li>
</ul>
<hr>
<h2 id="二、关键字"><a class="header-anchor" href="#二、关键字">¶</a>二、关键字</h2>
<h3 id="const"><a class="header-anchor" href="#const">¶</a>const</h3>
<ol>
<li>基础用法:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">const</span>* a <span class="comment">//前者为顶层const  后者底层const</span></span><br></pre></td></tr></table></figure>
<p>顶层const 表示 a不能再被赋值 ,底层const 表示不能通过*a进行赋值操作</p>
<h3 id="typedef和using"><a class="header-anchor" href="#typedef和using">¶</a>typedef和using</h3>
<ol>
<li>基础用法:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用别名</span></span><br><span class="line"><span class="keyword">typedef</span> typeName type;</span><br><span class="line"><span class="keyword">using</span> typeName=type;</span><br><span class="line"><span class="comment">//2.using 使用命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xx; <span class="comment">//不推荐这样使用会导致命名空间污染</span></span><br></pre></td></tr></table></figure>
<h3 id="auto"><a class="header-anchor" href="#auto">¶</a>auto</h3>
<ol>
<li>基础用法:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.自动推断类型</span><br><span class="line">auto returnFun a;</span><br><span class="line">&#x2F;&#x2F;2.后置返回类型</span><br><span class="line">auto fun(paras)-&gt;return Type</span><br></pre></td></tr></table></figure>
<h3 id="decltype"><a class="header-anchor" href="#decltype">¶</a>decltype</h3>
<ol>
<li>基础用法:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获得类型</span><br><span class="line">decltype (expression) </span><br></pre></td></tr></table></figure>
<h3 id="命名空间namespace"><a class="header-anchor" href="#命名空间namespace">¶</a>命名空间namespace</h3>
<ol>
<li>基础用法:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.定义命名空间</span><br><span class="line">namesapce xx&#123;</span><br><span class="line">code</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;2.使用命名空间</span><br><span class="line">xx::fun</span><br><span class="line">&#x2F;&#x2F;3.匿名命名空间</span><br><span class="line">namesapce&#123;</span><br><span class="line">&#125;</span><br><span class="line">匿名命名空间和static关键字都可以将该变量 函数的作用域控制在当前文件中</span><br></pre></td></tr></table></figure>
<p>关于匿名命名空间可以参看<a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/#unnamed-namespace-and-static-variables#">google c++ style</a></p>
<h3 id="class-struct-union"><a class="header-anchor" href="#class-struct-union">¶</a>class struct union</h3>
<ol>
<li>基础用法:<br>
class struct只是默认权限不同,一般仅仅当不含有成员函数的情况使用struct;<br>
union {<br>
int x<br>
double y<br>
} 同时只能一个变量占用内存,也就是说其内存大小= <code>sizeof (int)</code> /<code>sizeof (double)</code></li>
</ol>
<h2 id="三、宏"><a class="header-anchor" href="#三、宏">¶</a>三、宏</h2>
<h3 id="1-使用宏的保护机制"><a class="header-anchor" href="#1-使用宏的保护机制">¶</a>1.使用宏的保护机制</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef xx</span><br><span class="line">#define xx</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ul>
<li>关于xx的命名方式要体现项目的全路径,如 FOO_BAR_BAZ_H_</li>
<li>关于c++的编译单元是以单个文件进行的,宏保护就是对于单个文件进行的保护</li>
</ul>
<h3 id="2-使用-表示宏的换行"><a class="header-anchor" href="#2-使用-表示宏的换行">¶</a>2.使用\表示宏的换行</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;测试函数的宏定义</span><br><span class="line">#define Test(Name) \</span><br><span class="line">extern void testFunction(void);\</span><br><span class="line">class TestClass    \</span><br><span class="line">&#123;                  \</span><br><span class="line">  public:          \</span><br><span class="line">    TestClass()    \</span><br><span class="line"> &#123;                 \</span><br><span class="line">   cout&lt;&lt;#Name;    \</span><br><span class="line">   testFunction(); \</span><br><span class="line"> &#125;                 \</span><br><span class="line">&#125;instance;          \</span><br><span class="line">void testFunction(void)</span><br><span class="line">&#x2F;&#x2F;如何使用</span><br><span class="line">Test(fun)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;&quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子还能看出来extern 关系不仅仅在链接时取链接外部函数,还能链接同一个文件中的函数</p>
<h2 id="四、其他特性"><a class="header-anchor" href="#四、其他特性">¶</a>四、其他特性</h2>
<h3 id="1-使用-进行初始化"><a class="header-anchor" href="#1-使用-进行初始化">¶</a>1.使用{}进行初始化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int array[3]&#x3D;&#123;1,2,3&#125;</span><br><span class="line">std::vector&lt;int&gt;vec&#x3D;&#123;1,2,3&#125; &#x2F;&#x2F;google中提倡使用这个替代可变参数</span><br></pre></td></tr></table></figure>
<h3 id="2-关于c-内存管理"><a class="header-anchor" href="#2-关于c-内存管理">¶</a>2.关于c++内存管理</h3>
<ol>
<li>编译器只会主动调用栈对象的析构函数,而程序员要自己确定的事情是当该类中含有堆内存的时候要在析构函数中进行delete,delete的作用是调用析构函数,并且释放该指针指向的堆内存</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Innner</span>&#123;</span></span><br><span class="line">type * var;</span><br><span class="line">~()&#123;</span><br><span class="line"><span class="keyword">if</span>(var)</span><br><span class="line"><span class="keyword">delete</span> var;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>&#123;</span></span><br><span class="line">Inner * in;</span><br><span class="line">~()&#123;</span><br><span class="line"><span class="keyword">if</span>(in)</span><br><span class="line"><span class="keyword">delete</span> in;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(F f)</span></span>&#123; <span class="comment">//如果如此直接传递值,则会引起临时对象析构,导致内存问题</span></span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//仅仅当`句柄`为栈对象的时候才会编译器才会按照如此进行,在于该内存在函数作用域结束后就无法生存</span></span><br><span class="line">F f;<span class="comment">// 当该函数结束自动释放内存</span></span><br><span class="line"><span class="comment">//如果时堆指针</span></span><br><span class="line">F *f=<span class="keyword">new</span> <span class="built_in">F</span>()<span class="comment">//函数结束后则不会调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于栈对象</p>
<ul>
<li>又因为值传递问题,引出了 拷贝构造函数在 栈对象参数传递  栈对象返回时导致的析构,可能会引起内部指针指向同一处造成的内存问题,如果非要进行值传递,那么就要定义值传递的拷贝构造函数,以及值传递的赋值运算符</li>
<li>关于栈对象中共享堆成员内存,那么就要定义引用传递的拷贝构造函数和赋值运算符,以及析构函数</li>
</ul>
<figure class="highlight cpp"><figcaption><span>值行为的类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Inner&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">Inner</span>(<span class="keyword">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>&#123;</span></span><br><span class="line">Inner* in;</span><br><span class="line"><span class="built_in">F</span>(Inner* in):<span class="built_in">in</span>(in)&#123;&#125;</span><br><span class="line"><span class="comment">//值传递的拷贝构造函数</span></span><br><span class="line"><span class="built_in">F</span>(<span class="keyword">const</span> &amp;F f)&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;in=<span class="keyword">new</span> <span class="built_in">Inner</span>(f.in.a);</span><br><span class="line">&#125;</span><br><span class="line">F&amp; oprator=(<span class="keyword">const</span> &amp;F f)</span><br><span class="line"><span class="keyword">this</span>-&gt;in=<span class="keyword">new</span> <span class="built_in">Inner</span>(f.in.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时的析构函数按照正常的就可以</span></span><br><span class="line">~<span class="built_in">F</span>()&#123;</span><br><span class="line"><span class="keyword">if</span>(in)</span><br><span class="line"><span class="keyword">delete</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>引用行为的类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Class Inner&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">Inner</span>(<span class="keyword">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>&#123;</span></span><br><span class="line">Inner* in;</span><br><span class="line">std::<span class="keyword">size_t</span>* count;</span><br><span class="line"><span class="built_in">F</span>(Inner* in):<span class="built_in">in</span>(in),<span class="built_in">count</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//引用行为的拷贝构造函数</span></span><br><span class="line"><span class="built_in">F</span>(<span class="keyword">const</span> &amp;F f)&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;in=f.in;</span><br><span class="line">  <span class="keyword">this</span>.count=f.count;</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用行为的赋值运算符</span></span><br><span class="line">F&amp; oprator=(<span class="keyword">const</span> &amp;F f)</span><br><span class="line"> count--;</span><br><span class="line"> <span class="built_in">clear</span>();</span><br><span class="line"> <span class="keyword">this</span>.in=f.in;</span><br><span class="line"> <span class="keyword">this</span>.count=f.count;</span><br><span class="line"> count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时的析构函数按照正常的就可以</span></span><br><span class="line">~<span class="built_in">F</span>()&#123;</span><br><span class="line">count--;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">delete</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如此就完成了对于中栈对象值行为和拷贝行为的管理</span></span><br></pre></td></tr></table></figure>
<p>对于堆对象</p>
<ul>
<li>还是上述的问题,堆对象句柄c++编译器不会为之进行主动析构,只有程序员主动调用析构函数,理解一下无论时栈还是堆句柄,我们所做的都应该是在其句柄声明周期结束的时候去判断是否应该是否该内存,对于分配在栈上的内存,编译器就是很自信的直接清除了,而令人困惑的就是堆这部分内存.</li>
<li>我的理解是,如果你创建了一个栈对象,并且保持值行为,那么这个对象的内存无论是栈成员,还是指针堆成员,都应该伴随着该句柄的生命而结束;如果定义的是引用行为,那么就要使用引用计数来判定何时释放堆成员.</li>
<li>使用原生指针作为堆句柄时,问题在于你没有办法使用c++本身语法进行引用计数判定</li>
<li>一般来说存在new 就要有与之匹配的delete</li>
</ul>
<figure class="highlight cpp"><figcaption><span>堆句柄</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">A *a=NEW <span class="built_in">A</span>();</span><br><span class="line">A *a2=NEW <span class="built_in">A</span>();</span><br><span class="line"><span class="comment">//对于指针数据类型本身来说仅仅是一次值覆盖过程,但是造成了a本身指向的内存没有办法释放</span></span><br><span class="line"><span class="comment">//原因在于type*这个类型实质还是指针,没有办法执行 所谓的引用行为赋值运算符,通过智能指针将指针封装成对象类型就能够限制此行为</span></span><br><span class="line">a=a2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>智能指针的实质就是通过将指针封装成栈对象,此时编译器对于智能指针这种栈对象就会按照一般情况来处理</p>
<h3 id="3-左右值"><a class="header-anchor" href="#3-左右值">¶</a>3. 左右值</h3>
<p>将没有指向<code>句柄</code>的量称之为右值</p>
<ul>
<li>如临时变量 1 a 等,</li>
<li>由左值运算出的结果未赋值的情况<br>
string a=“123”;string b=123&quot;; a+b(右值)</li>
</ul>
<p>引用函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span>&#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> &amp;</span>; <span class="comment">//匹配this为左值的情况</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>&amp;&amp; <span class="comment">//匹配this是右值的情况,&amp;和const一样可以参与函数重载</span></span></span><br><span class="line"><span class="function"> Temp <span class="title">test2</span><span class="params">()</span></span>;<span class="comment">//该函数函数的就是右值</span></span><br><span class="line"> <span class="function">Temp&amp; <span class="title">test3</span><span class="params">()</span></span>;<span class="comment">//返回左值</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">test2</span>().<span class="built_in">test</span>()<span class="comment">//匹配左值</span></span><br><span class="line"> <span class="built_in">test3</span>().<span class="built_in">test</span>() <span class="comment">//匹配右值函数</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>对于熟悉的我就不会列出例子 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">fancylight</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.fancylight.top/2019/01/04/c-%E5%9F%BA%E7%A1%80/">https://www.fancylight.top/2019/01/04/c-%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.fancylight.top" target="_blank">博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础    </a></div><div class="post_share"><div class="social-share" data-image="/img/java.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/01/04/c/"><img class="prev_cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">c++杂项</div></div></a></div><div class="next-post pull_right"><a href="/2018/11/12/%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81-io/"><img class="next_cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">标准库源码-io</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/01/04/c/" title="c++杂项"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-01-04</div><div class="relatedPosts_title">c++杂项</div></div></a></div><div class="relatedPosts_item"><a href="/2019/01/04/数据库概论/" title="数据库概论"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-01-04</div><div class="relatedPosts_title">数据库概论</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/06/数据库概论二/" title="数据库概论二"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-06</div><div class="relatedPosts_title">数据库概论二</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/09/数据库概论三/" title="数据库概论三"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-09</div><div class="relatedPosts_title">数据库概论三</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/13/数据库概论五/" title="数据库概论五"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-13</div><div class="relatedPosts_title">数据库概论五</div></div></a></div><div class="relatedPosts_item"><a href="/2019/05/14/数据库概论六/" title="数据库概论六"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-05-14</div><div class="relatedPosts_title">数据库概论六</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '624d139155758ea48077',
  clientSecret: 'cc126a301586ea63779cec6a6b53101749dbc9dd',
  repo: 'gittalk_issue',
  owner: 'fancylight',
  admin: ['fancylight'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By fancylight</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>